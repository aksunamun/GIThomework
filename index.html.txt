•	git config – команда для указания пользовательских настроек, таких как электронная почта, имя пользователя, формат и т.д.;
для всех локальных репозиториев:
        git config --global user.name blabla - устанавливает имя, которое будет отображаться в поле автора у выполняемых вами коммитов;
        git config --global user.email blabla@bla - устанавливает адрес электронной почты, который будет отображаться в информации о выполняемых вами коммитах;
для конкретного проекта (локального репозитория):  
        git config user.name blabla
        git config user.email blabla@bla;
•	git init [название проекта] - создаёт новый локальный репозиторий с заданным именем (то есть будет создана папка с названием проекта в котором будет находиться репозиторий);
	git init ./  -  создаёт новый локальный репозиторий в текущей директории;
•	git status - перечисляет все новые или изменённые файлы, которые нуждаются в фиксации;
•	git add – ‘выделяет’ нужные файлы и создает ‘набор’, который потом можно закоммитить (сделать сохраненную версию);
•	git commit -m " Добавьте здесь любое сообщение описывающее коммит" - фиксирует ‘выделенные’ командой git add изменения и сохраняет их в историю версий с именем, которое ты указал в ‘сообщении, описывающем коммит’;
        git commit - в таком случае откроется текстовый редактор по умолчанию, в котором нужно будет описать коммит.  Если это произошло случайно, введите :q и нажмите Enter;
•	git log - история коммитов для текущей ветки;
	git log --follow [файл] - история изменений конкретного файла, включая его переименование;
•	git checkout - команда для создания веток или переключения между ними;
        git checkout [имя ветки] - переключяется на выбранную ветку и одновременно обновляет рабочую директорию до её состояния;
        git checkout -b [имя ветки] - создаёт новую ветку с таким-то именем и одновременно переходит на нее;
        git checkout -d [имя ветки] - удаляет выбранную ветку;
•	git branch - отображает список веток в локальном репозитории. 
Текущая ветка будет помечена звездочкой ‘*’.
        git branch [имя ветки] - создаёт новую ветку с таким-то именем;
        git branch -d [имя ветки] - удаляет выбранную ветку;
•	git push [удалённый репозиторий] [ветка] - помещает все изменения локальной ветки в удалённый репозиторий (чтобы сделать ветку доступной для других пользователей);
•	git pull – позволяет получить изменения из удаленного репозитория в локальный рабочий каталог (обновить ваш локальный каталог на его последнюю версию из удаленного репозитория);
•	git merge [имя ветки] - позволяет вносит изменения указанной ветки в текущую активную ветку (объединять активную ветку с какой-либо другой);
        git diff [имя ветки источника] [имя целевой ветки] – позволяет просмотреть различия до слияния веток;
•	git clone - используется для клонирования репозитория.
клонирование репозитория на удаленном сервере:
        git clone имя.пользователя@хост:/путь/до/репозитория
клонирование локального репозитория:
        git clone /путь/до/репозитория;


.gitignore файл - служит для указания в нём файлов и папок, которые необходимо скрыть от системы контроля версий git. 

Как правило, скрывают файлы или папки, которые автоматически генерируют своё содержимое, либо имеют конфигурационные параметры, которые могут различаться у тех, кто совместно работает над проектом.
 Правила синтаксиса этого файла:

•	Одна строчка - одно правило,
•	Пустые строки игнорируются,
•	Комментарии доступны через решётку(#) в начале строки,
•	Символ "/" в начале строки указывает, что правило применяется только к файлам и папкам, которые располагаются в той же папке, что и сам файл .gitignore,
•	Доступно использовать спецсимволы:
- звёздочка(*) заменяет любое количество символов(ноль или больше);
- вопросик(?) заменяет от нуля до одного символа. Можно размещать в любом месте правила;
- две звёздочки(**) используются для указания любого количества поддиректорий, подробнее смотри ниже в примерах,
- восклицательный знак(!) в начале строки означает инвертирование правила, необходим для указания исключений из правил игнорирования;
- cимвол "\" используется для экранирования спецсимволов, например, чтобы игнорировать файл с именем "!readme!.txt", нужно написать такое правило: "\!readme!.txt",
•	Для игнорирования всей директории, правило должно оканчиваться на слэш(/), в противном случае правило считается именем файла.


Advanced
git revert - позволяет отменить уже опубликованные коммиты с помощью новых коммитов.
Она создает новые коммиты, по одному на каждый отменяемый коммит. Таким образом, если нужно отменить все коммиты после aaaaaa:
# можно перечислить отменяемые коммиты
git revert bbbbbb cccccc dddddd

# можно задать диапазон от более раннего к более позднему (новому)
git revert bbbbbb..dddddd

# либо в относительных ссылках
git revert HEAD~2..HEAD

# можно отменить коммит слияния, указывая явным образом номер предка (в нашем примере таких нет):
git revert -m 1 abcdef

# после этого подтвердите изменения:
git commit -m'детальное описание, что и почему сделано'

•	git reset - позволяет ‘сбросить’ индексирование (выделение командой add) файлов рабочего каталога до последнего состояния коммита;
git reset HEAD [имя файла] - позволяет исключить такой-то файл из индекса (например, если случайно набрали git add * и проиндексировали все файлы);
•	git rebase – ввозволяет интерактивно перемещаться между коммитами и редактировать их («перезаписывать историю»): изменять «сообщение» коммита, порядок следования коммитов (в том числе удалять ненужные), «уплотнять» (сливать в один) коммиты, разбивать коммит на несколько.
•	git cherry-pick  - позволяет переносить отдельные коммиты из одного места репозитория в другое, обычно между ветками разработки и обслуживания.
Чтобы использовать команду:
1. Убедитесь, что вы находитесь в той ветке, к которой хотите применить коммит:
git checkout master
2. Выполните следующее:
git cherry-pick [имя коммита]
•	git stash – позволяет сохранить изменения на временной основе, не добавляя их в коммит.
Часто возникает такая ситуация, что пока вы работаете над частью своего проекта, всё находится в беспорядочном состоянии, а вам нужно переключить ветки, чтобы немного поработать над чем-то другим. Проблема в том, что вы не хотите делать коммит с наполовину доделанной работой только для того, чтобы позже можно было вернуться в это же состояние.
Прятанье поглощает грязное состояние рабочего каталога, то есть изменённые отслеживаемые файлы и изменения в индексе, и сохраняет их в стек незавершённых изменений (то есть создает "заначку", которую вы потом в любое время можете снова применить).
git stash list – отображает список созданных "заначек";
git stash apply [имя "заначки"] -  применить такую-то "заначку" (спрятанную работу), например git stash apply stash@{2};
git stash apply - применить последнюю спрятанную работу;
git stash apply –index - применить последнюю спрятанную работу + файлы в индексе;
git stash branch - создает новую ветку с началом из того коммита, на котором вы находились во время прятанья, восстанавливает в ней вашу работу и затем удаляет спрятанное, если оно применилось успешно (удобно для того, чтобы легко восстановить свою работу, а затем поработать над ней в новой ветке);
git stash drop [имя "заначки"] – удаляет спрятанную работу из стека;
git stash pop - применяет спрятанные изменения и сразу же удаляет их из стека.
